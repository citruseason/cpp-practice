# C++ 기초

실습 수업 전 알고 있어야할 용어 정리

## 기본용어

### 변수

변수(variable)란 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받는 **메모리 공간**을 의미

저장된 값은 변경될 수 있음

#### **변수의 이름 생성 규칙**

1. 영문자, 숫자, 언더스코어로만 구성
2. 숫자로 시작 X
3. 이름 사이에 공백 X
4. C++에서 미리 지정된 키워드(keyword)는 변수로 사용 불가능
5. 변수 이름의 길이의 제한 X



------



### 연산자

연산을 수행하는 기호

C++에서 연산자란 프로그램의 논리식이나 산술식을 표현하고 처리하기 위해서 제공되는 다양한 기호들을 말함

#### 산술 연산자

사칙연산을 다루는 기본적인 연산자

| 산술 연산자 |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|      +      |         왼쪽의 피연산자에 오른쪽의 피연산자를 더함.          |
|      -      |         왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.          |
|      *      |         왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.          |
|      /      |         왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.          |
|      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |



#### 대입 연산자

대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽 

또한, 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재

| 대입 연산자 |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|      =      |        왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.         |
|     +=      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
|     -=      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
|     *=      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
|     /=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함. |
|     %=      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함. |



#### 비교 연산자

비교 연산자는 피연산자 사이의 상대적인 크기를 판단하는 연산자 

비교 연산자는 왼쪽의 피연산자와 오른쪽의 피연산자를 비교하여, 어느 쪽이 더 큰지, 작은지, 또는 서로 같은지를 판단 

비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽

| 비교 연산자 |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|     ==      |   왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 1을 반환함.   |
|     !=      | 왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 1을 반환함. |
|      >      |   왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 1을 반환함.   |
|     >=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 1을 반환함. |
|      <      |  왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 1을 반환함.  |
|     <=      | 왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 1을 반환함. |



#### 논리 연산자

논리 연산자는 주어진 논리식을 판단하여, 참(true)과 거짓(false)을 결정하는 연산자AND 연산과 OR 연산은 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽

NOT 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽

| 논리 연산자 |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|     &&      |       논리식이 모두 참이면 1을 반환함. (논리 AND 연산)       |
|    \|\|     |   논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)   |
|      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |



#### 비트 연산자

비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자

또한, 비트 단위로 왼쪽이나 오른쪽으로 전체 비트를 이동하거나, 1의 보수를 만들 때도 사용

| 비트 연산자 |                             설명                             |
| :---------: | :----------------------------------------------------------: |
|      &      |    대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)    |
|     \|      | 대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산) |
|      ^      |   대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)    |
|      ~      | 비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수) |
|     <<      | 지정한 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산) |
|     >>      | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |



#### 삼항 연산자

```c++
조건식 ? 반환값1 : 반환값2
```



------



### 자료형

자료형은 크게 정수형, 실수형, 문자형 그리고 bool형 타입으로 나눌 수 있음

#### 정수형 타입

정수란 부호를 가지고 있으며, 소수 부분이 없는 수를 의미

|    정수형 타입     | 할당되는 메모리의 크기 |
| :----------------: | :--------------------: |
|   (signed) short   |        2 바이트        |
|   unsigned short   |        2 바이트        |
|    (signed) int    |        4 바이트        |
|    unsigned int    |        4 바이트        |
|   (signed) long    |        4 바이트        |
|   unsigned long    |        4 바이트        |
| unsigned long long |        8 바이트        |



#### 실수형 타입

실수란 소수부나 지수가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가짐

| 실수형 타입 | 할당되는 메모리의 크기 |
| :---------: | :--------------------: |
|    float    |        4 바이트        |
|   double    |        8 바이트        |
| long double |   double형과 동일함.   |



#### 문자형 타입

문자형 데이터란 작은 정수나 문자 하나를 표현할 수 있는 타입을 가리킴

|  문자형 타입  | 할당되는 메모리의 크기 |
| :-----------: | :--------------------: |
| (signed) char |        1 바이트        |
| unsigned char |        1 바이트        |

#### bool 형 타입

bool형은 참(true)이나 거짓(false) 중 한 가지 값만을 가질 수 있는 불리언 타입



------



### 구조체

구조체(structure type)란 사용자가 C++의 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입

구조체는 기본 타입만으로는 나타낼 수 없는 복잡한 데이터를 표현할 수 있음

```c++
struct 구조체이름 {
    멤버변수1의타입 멤버변수1의이름;
    멤버변수2의타입 멤버변수2의이름;
    ...
};
```



------



### 조건문

조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문

#### if / else if / else

```c++
if (조건식1) {
    조건식1의 결과가 참일 때 실행하고자 하는 명령문;
}
else if (조건식2) {
    조건식2의 결과가 참일 때 실행하고자 하는 명령문;
}
else {
    조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;
}
```

#### switch case

```c++
switch (조건 값) {
    case 값1:
        조건 값이 값1일 때 실행하고자 하는 명령문;
        break;
    case 값1:
        조건 값이 값2일 때 실행하고자 하는 명령문;
        break;
    ...
    default:
        조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;
        break;
}
```

#### 삼항연산자

```c++
조건식 ? 반환값1 : 반환값2
```



------





### 반복문

반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문

#### while / do while

```c++
while (조건식) {
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}

do {
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
} while (조건식);
```



#### for

```c++
for (초기식; 조건식; 증감식) {
    조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
}

// 범위 기반 ( >= C++11)
int arr[5] = {1, 3, 5, 7, 9};
for (int element : arr) {
    cout << element << " ";
}

```



------



### 배열

배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의

배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 함

**가장 기본적인 자료 구조**

```c++
타입 배열이름[배열길이 or Empty] = {값1, 값2, 값3, ... 값(배열길이 or N)};
```



------



### 함수, 메소드

#### 함수

함수(function)란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합으로 정의

```c++
리턴자료형 함수이름 (매개변수 목록) {
  함수 몸체
}
```

#### 메소드

메소드(method)란 객체에서 맴버 함수로 사용되는 함수를 보고 메소드라함

<br />

<br />

## 고급 용어

### 포인터

포인터(pointer)란 메모리의 주소값을 저장하는 변수이며, 포인터 변수라고도 부름

#### 주소 연산자 (&)

주소 연산자는 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환

'&'기호는 앰퍼샌드(ampersand)라고 읽으며, 번지 연산자라고도 부름

#### 참조 연산자(*)

참조 연산자는 포인터의 이름이나 주소 앞에 사용하여, 포인터에 저장된 주소에 저장되어 있는 값을 반환

'*'기호는 역참조 연산자로 에스크리터(asterisk operator)라고 불림

```c++
int x = 7;            // 변수의 선언
int *ptr = &x;        // 포인터의 선언
int **pptr = &ptr;    // 포인터의 참조
```



------



### 메모리 동적 할당

데이터 영역과 스택 영역에 할당되는 메모리의 크기는 컴파일 타임(compile time)에 미리 결정

힙 영역의 크기는 프로그램이 실행되는 도중인 런 타임(run time)에 사용자가 직접 결정런타임에 메모리를 할당받는 것을 메모리의 동적 할당(dynamic allocation)이라고 함

```c++
타입* 포인터이름 = new 타입; // 메모리 할당
delete 포인터이름;        // 메모리 해제
```



------



### 메모리 스텍 영역과 힙 영역

#### 스택

메모리의 스택(Stack) 영역이란 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸

후입선출(LIFO, Last-In First-Out)으로 동작함

`높은 주소 -> 낮은 주소`

#### 힙

메모리의 힙(Heap) 영역이란 사용자가 직접 관리 할 수 있는 영역

메모리 동적할당에서 쓰이는 영역, 동적으로 할당 및 해제

`낮은 주소 -> 높은 주소`



------



### C++의 스트링

##### C 스타일 스트링

C언어에서의 문자열 사용방법은 char을 배열로 이용하여 값을 받음

```c++
char str1[] = "Hello";
char str2[6] = "Hello";
char str3[6] = {'H','e','l','l','o','\0'}
```

또는 포인터를 이용하여 값을 받음

```c++
char str* = "Hello";
```

이때 `Hello`는 메모리에 `H_e_l_l_o_(null)`이와 같은 형태로 할당되어 있음

##### C++ 스타일 스트링

String 클래스의 도입으로 사용자가 길이지정을 해줄 필요가 없어짐 (사용성 증대)

**사용방법**

```c++
string str1 = "Hello";
str1 = "World";
cout << str << str1.length() << endl;
```

##### 비표준 스트링

C++에서 String 클래스를 커스터마이징하기 위해서 사용함

`operator` 와 같은 연산자 오버로딩을 통하여 직접 String 클래스 생성



------



### 참조형

참조형은 다른 객체나 값의 별칭으로 사용되는 타입

원본의 주소값을 사용하기 때문에 직접적인 변경이 가능

`Pass by reference` 기법을 쓸 때 필요

C++은 3가지 종류의 참조형을 지원

- none-const 값 참조형
- const 값 참조형
- r-value 참조형

```c++
/*
l-value는 이름에 의해 프로그래밍으로 제어 가능
하지만 r-value는 이름이 없어서 내부적으로 사용되고 내부적으로 사라짐
*/

// non-const
int value1 = 5;
int& ref1 = value1;

// const
const int value2 = 7; 
int& ref2 = value2;

// r-value
int& ref3 = 6;
```



------



### 예외 처리

예외처리란 프로그램 실행 중 얘기치 못한 오류를 만났을 경우 이를 처리하는 과정을 `예외 처리`라고 함

**예외 처리 방법**

1. if문을 통한 직접적인 컨트롤
2. try catch, throw를 통한 컨트롤
